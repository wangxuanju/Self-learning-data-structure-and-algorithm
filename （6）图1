临接矩阵
// 时间复杂度为O(n+n^2+e)

#define MAXVEX 100			// 最大顶点数
#define INFINITY 65535		// 用65535来代表无穷大

typedef struct
{
	char vexs[MAXVEX];				// 顶点表
	int arc[MAXVEX][MAXVEX];		// 邻接矩阵
	int numVertexes, numEdges;		// 图中当前的顶点数和边数
} MGraph;

// 建立无向网图的邻接矩阵
void CreateMGraph(MGraph *G)
{
	int i, j, k, w;
	
	printf("请输入顶点数和边数：\n");
	scanf("%d %d", &G->numVertexes, &G->numEdges);
	
	for( i=0; i < G->numVertexes; i++ )
	{
		scanf("%c", &G->vexs[i]);
	}
	
	for( i=0; i < G->numVertexes; i++ )
	{
		for( j=0; j < G->numVertexes; j++ )
		{
			G->arc[i][j] = INFINITY;			// 邻接矩阵初始化
		}
	}
	
	for( k=0; k < G->numEdges; k++ )
	{
		printf("请输入边(Vi,Vj)上的下标i,下标j和对应的权w:\n");		// 这只是例子，提高用户体验需要进行改善
		scanf("%d %d %d", &i, &j, &w);
		G->arc[i][j] = w;
		G->arc[j][i] = G->arc[i][j];			// 是无向网图，对称矩阵
	}
}


邻接表
#define MAXVEX 100

typedef struct EdgeNode			// 边表结点
{
	int adjvex;					// 邻接点域，存储该顶点对应的下标
	int weight;					// 用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;		// 链域，指向下一个邻接点
} EdgeNode;

typedef struct VertexNode		// 顶点表结点
{
	char data;					// 顶点域，存储顶点信息
	EdgeNode *firstEdge;		// 边表头指针
} VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes, numEdges;	// 图中当前顶点数和边数
} GraphAdjList;

// 建立图的邻接表结构
void CreateALGraph(GraphAdjList *G)
{
	int i, j, k;
	EdgeNode *e;
	
	printf("请输入顶点数和边数：\n");
	scanf("%d %d", &G->numVertexes, &G->numEdges);
	
	// 读取顶点信息，建立顶点表
	for( i=0; i < G->numVertexes; i++ )
	{
		scanf("%c", &G->adjList[i].data);
		G->adjList[i].firstEdge = NULL;		// 初始化置为空表
	}
	
	for( k=0; k < G->numEdges; k++ )
	{
		printf("请输入边(Vi,Vj)上的顶点序号：\n");
		scanf("%d %d", &i, &j);
		
		e = (EdgeNode *)malloc(sizeof(EdgeNode));
		e->adjvex = j;						// 邻接序号为j
		e->next = G->adjList[i].firstEdge;
		G->adjList[i].firstEdge = e;
		
		e = (EdgeNode *)malloc(sizeof(EdgeNode));
		e->adjvex = i;						// 邻接序号为i
		e->next = G->adjList[j].firstEdge;
		G->adjList[j].firstEdge = e;
	}
}


邻接表的深度遍历
#include<stdio.h>
#include<windows.h>
// 邻接表的深度有限递归算法
// 邻接表的创建代码见第五十七讲源代码部分
// 鱼C工作室(www.fishc.com)

#define TRUE 1
#define FALSE 0
#define MAX 256

typedef int Boolean;	// 这里我们定义Boolean为布尔类型，其值为TRUE或FALSE
Boolean visited[MAX];	// 访问标志的数组

void DFS(GraphAdjList GL, int i)
{
	EdgeNode *p;
	
	visited[i] = TRUE;
	printf("%c " GL->adjList[i].data);
	p = GL->adjList[i].firstEdge;
	
	while(p)
	{
		if( !visited[p->adjvex] )
		{
			DFS(GL, p->adjvex);
		}
		p = p->next;
	}
}

// 邻接表的深度遍历操作
void DFSTraverse(GraphAdjList GL)
{
	int i;
	
	for( i=0; i < GL->numVertexes; i++ )
	{
		visited[i] = FALSE;		// 初始化所有顶点状态都是未访问过状态
	}
	
	for( i=0; i < GL->numVertexes; i++ )
	{
		if( !visited[i] )		// 若是连通图，只会执行一次
		{
			DFS(GL, i);
		}
	}
}


邻接矩阵的深度遍历
// 邻接矩阵的深度有限递归算法
// 邻接矩阵的创建代码见第五十六讲源代码部分
// 鱼C工作室(www.fishc.com)

#define TRUE 1
#define FALSE 0
#define MAX 256

typedef int Boolean;	// 这里我们定义Boolean为布尔类型，其值为TRUE或FALSE
Boolean visited[MAX];	// 访问标志的数组

void DFS(MGraph G, int i)
{
	int j;
	
	visited[j] = TRUE;			// 访问过的顶点设置为TRUE
	printf("%c ", G.vexs[i]);	// 打印顶点
	for( j=0; j < G.numVertexes; j++ )
	{
		if( G.arc[i][j]==1 && !visited[j] )
		{
			DFS(G, j);			// 对为访问的邻接顶点递归调用
		}
	}
}

// 邻接矩阵的深度遍历操作
void DFSTraverse(MGraph G)
{
	int i;
	
	for( i=0; i < G.numVertexes; i++ )
	{
		visited[i] = FALSE;		// 初始化所有顶点状态都是未访问过状态
	}
	
	for( i=0; i < G.numVertexes; i++ )
	{
		if( !visited[i] )		// 若是连通图，只会执行一次
		{
			DFS(G, i);
		}
	}
}
